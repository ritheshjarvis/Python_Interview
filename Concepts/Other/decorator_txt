In Python, a decorator is a special function that modifies the behavior of another function (or method) without changing its actual code.

ðŸ”§ Real-world analogy:
Imagine you have a gift (function) and you wrap it in fancy paper (decorator) to enhance its appearanceâ€”the gift is the same, but it looks better.

ðŸ§  Basic Concept
A decorator is a function that takes another function as input and returns a new function.

âœ… Example without @ syntax:
python
Copy
Edit
def decorator_function(original_function):
    def wrapper_function():
        print("Before the function runs")
        original_function()
        print("After the function runs")
    return wrapper_function

def say_hello():
    print("Hello!")

# Manually decorating
decorated = decorator_function(say_hello)
decorated()
Output:

pgsql
Copy
Edit
Before the function runs
Hello!
After the function runs
âœ… Using @ decorator syntax (cleaner):
python
Copy
Edit
def decorator_function(original_function):
    def wrapper_function():
        print("Before the function runs")
        original_function()
        print("After the function runs")
    return wrapper_function

@decorator_function
def say_hello():
    print("Hello!")

say_hello()
ðŸŽ¯ When are decorators useful?
Logging

Authentication

Access control

Timing function execution

Caching results

ðŸ§ª Example: Logging Decorator
python
Copy
Edit
def log_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with {args} and {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_decorator
def add(a, b):
    return a + b

print(add(2, 3))